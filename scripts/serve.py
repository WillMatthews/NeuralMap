"""Web server for visualizing generated map tiles."""
import os
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

import torch
import yaml
from flask import Flask, send_file, jsonify, render_template_string
from PIL import Image
import io
import numpy as np
from pathlib import Path

from src.model import CoordinateNeuralField
from src.data_utils import deg2num, num2deg, get_tile_url, lat_lon_to_normalized


app = Flask(__name__)

# Global model
model = None
device = None
config = None
model_loaded = False


def load_model():
    """Load the trained model."""
    global model, device, config, model_loaded
    
    if model_loaded:
        return
    
    # Load config
    with open('config.yaml', 'r') as f:
        config = yaml.safe_load(f)
    
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    print(f"Using device: {device}")
    
    # Load model
    model_path = Path(config['paths']['models_dir']) / 'best_model.pt'
    if not model_path.exists():
        # Try latest checkpoint
        checkpoints = list(Path(config['paths']['models_dir']).glob('checkpoint_*.pt'))
        if checkpoints:
            model_path = max(checkpoints, key=lambda p: p.stat().st_mtime)
            print(f"Loading latest checkpoint: {model_path}")
        else:
            raise FileNotFoundError(f"No model found in {config['paths']['models_dir']}")
    
    checkpoint = torch.load(model_path, map_location=device)
    
    # Create model
    model_config = config['model']
    data_config = config['data']
    model = CoordinateNeuralField(
        hidden_dim=model_config['hidden_dim'],
        num_mlp_layers=model_config.get('num_mlp_layers', model_config.get('num_layers', 8)),
        num_frequencies=model_config.get('num_frequencies', 10),
        tile_size=data_config['tile_size'],
        dropout=model_config['dropout'],
        num_attention_blocks=model_config.get('num_attention_blocks', 2)
    ).to(device)
    
    model.load_state_dict(checkpoint['model_state_dict'])
    model.eval()
    
    model_loaded = True
    print(f"Model loaded from {model_path}")


@app.route('/')
def index():
    """Serve the main page."""
    html = """
<!DOCTYPE html>
<html>
<head>
    <title>Map Compression Model - Tile Viewer</title>
    <meta charset="utf-8">
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #osm-map {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            border-right: 2px solid #333;
        }
        #generated-map {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
        }
        .map-label {
            position: absolute;
            top: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 12px;
            z-index: 1000;
        }
        #osm-label {
            left: 10px;
        }
        #generated-label {
            right: 10px;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div id="map-container">
        <div class="map-label" id="osm-label">OpenStreetMap (Reference)</div>
        <div class="map-label" id="generated-label">Generated by Model</div>
        <div id="osm-map"></div>
        <div id="generated-map"></div>
        <div class="controls">
            <button onclick="resetView()">Reset View</button>
            <span id="zoom-level">Zoom: 5</span>
        </div>
    </div>

    <script>
        // Initialize OSM map
        const osmMap = L.map('osm-map').setView([41.0, -74.0], 5);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 18
        }).addTo(osmMap);

        // Initialize generated map
        const generatedMap = L.map('generated-map').setView([41.0, -74.0], 5);
        
        // Custom tile layer for generated tiles
        const generatedTileLayer = L.tileLayer('/tile/{z}/{x}/{y}', {
            attribution: 'Generated by Model',
            maxZoom: 10,
            tileSize: 256,
            zoomOffset: 0
        }).addTo(generatedMap);

        // Sync map movements
        osmMap.on('moveend', () => {
            const center = osmMap.getCenter();
            const zoom = osmMap.getZoom();
            generatedMap.setView(center, zoom);
            updateZoomLevel(zoom);
        });

        generatedMap.on('moveend', () => {
            const center = generatedMap.getCenter();
            const zoom = generatedMap.getZoom();
            osmMap.setView(center, zoom);
            updateZoomLevel(zoom);
        });

        osmMap.on('zoomend', () => {
            updateZoomLevel(osmMap.getZoom());
        });

        function updateZoomLevel(zoom) {
            document.getElementById('zoom-level').textContent = `Zoom: ${zoom}`;
        }

        function resetView() {
            osmMap.setView([41.0, -74.0], 5);
            generatedMap.setView([41.0, -74.0], 5);
        }
    </script>
</body>
</html>
    """
    return render_template_string(html)


@app.route('/tile/<int:z>/<int:x>/<int:y>')
def get_tile(z, x, y):
    """Generate a tile using the model."""
    global model, device, config
    
    if not model_loaded:
        load_model()
    
    try:
        # Get center lat/lon of tile
        n = 2.0 ** z
        center_lat, center_lon = num2deg(x + 0.5, y + 0.5, z)
        
        # Normalize coordinates
        min_lat = config['region']['min_lat']
        max_lat = config['region']['max_lat']
        min_lon = config['region']['min_lon']
        max_lon = config['region']['max_lon']
        
        coords = lat_lon_to_normalized(
            center_lat, center_lon, z,
            min_lat, max_lat, min_lon, max_lon
        )
        
        # Generate tile
        with torch.no_grad():
            coords_tensor = torch.from_numpy(coords).float().unsqueeze(0).to(device)
            pred_image = model(coords_tensor)
            
            # Convert to PIL Image
            img_array = pred_image[0].cpu().permute(1, 2, 0).numpy()
            img_array = np.clip(img_array * 255, 0, 255).astype(np.uint8)
            img = Image.fromarray(img_array)
        
        # Save to bytes
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        
        return send_file(img_bytes, mimetype='image/png')
    
    except Exception as e:
        print(f"Error generating tile {z}/{x}/{y}: {e}")
        # Return transparent/black tile on error
        img = Image.new('RGB', (256, 256), color='black')
        img_bytes = io.BytesIO()
        img.save(img_bytes, format='PNG')
        img_bytes.seek(0)
        return send_file(img_bytes, mimetype='image/png')


if __name__ == '__main__':
    print("Loading model...")
    load_model()
    print("Starting web server on http://localhost:5000")
    app.run(host='0.0.0.0', port=5000, debug=False)
